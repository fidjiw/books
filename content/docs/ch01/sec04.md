---
title: 1.4 切片
weight: 4
---

# 1.4 切片

![image-20220121185430405](https://gitee.com/fidjiw/images/raw/master/img/image-20220121185430405.png)



## 1.4.1 为什么要使用切片

因为数组的长度是固定的并且数组长度是属于类型的一部分， 所以数组有很多的局限性  



## 1.4.2 切片的定义

切片（Slice） 是一个拥有相同类型元素的 **可变长度的序列**  

它是基于数组类型做的一层封装  

它非常灵活， 支持自动扩容  

切片是一个引用类型， 它的内部结构包含**地址、 长度和容量**  

声明切片类型的基本语法如下：

```go
var name []T

// name:表示变量名
// T:表示切片中的元素类型

// 声明切片类型
var a []string //声明一个字符串切片
var b = []int{} //声明一个整型切片并初始化
var c = []bool{false, true} //声明一个布尔切片并初始化
```



## 1.4.3 认识nil

切片是引用类型， 不支持直接比较， 只能和 nil 比较  

当你声明了一个变量 , 但却还并没有赋值时 , golang 中会自动给你的变量赋值一个默认零值  

每种类型对应的零值不同

```go
bool -> false
numbers -> 0
string-> ""
pointers -> nil
slices -> nil
maps -> nil
channels -> nil
functions -> nil
interfaces -> ni
```



## 1.4.4 切片的循环遍历

切片的循环遍历和数组的循环遍历是一样的  

```go
var a = []string{"北京", "上海", "深圳"}
// 方法 1： for 循环遍历
for i := 0; i < len(a); i++ {
	fmt.Println(a[i])
}

// 方法 2： for range 遍历
for index, value := range a {
	fmt.Println(index, value)
}
```



## 1.4.5 基于数组定义切片

由于切片的底层就是一个数组， 所以我们可以基于数组定义切片  

```go
// 基于数组定义切片
a := [5]int{55, 56, 57, 58, 59}
b := a[1:4] //基于数组 a 创建切片， 包括元素 a[1],a[2],a[3]
fmt.Println(b) //[56 57 58

// 还支持如下方式：
c := a[1:] //[56 57 58 59]
d := a[:4] //[55 56 57 58]
e := a[:] //[55 56 57 58 59]
```



## 1.4.6 切片再切片



## 1.4.7 切片的长度和容量

## 1.4.8 切片的本质

## 1.4.9 使用make函数构造切片

## 1.4.10 切片不能直接比较

## 1.4.11 切片是引用数据类型

## 1.4.12 append方法为切片添加元素

## 1.4.13 切片的扩容策略

## 1.4.14 copy方法复制切片

## 1.4.15 从切片中删除元素



